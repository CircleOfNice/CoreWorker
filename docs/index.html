<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl">
  <title data-ice="title">API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="git+https://github.com/CircleOfNice/CoreWorker">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/DuplexStream.js~DuplexStream.html">DuplexStream</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Condition">Condition</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-DuplexStream">DuplexStream</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Instance">Instance</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-NodeProcess">NodeProcess</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-null">null</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Process">Process</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RegExp">RegExp</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Result">Result</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Validator">Validator</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><div data-ice="index" class="github-markdown"><h1 id="coreworker">CoreWorker</h1>
<p><img src="https://scontent-frt3-1.cdninstagram.com/hphotos-xap1/t51.2885-15/e15/11281977_943814572305837_858119153_n.jpg"></p>
<h1 id="motivation">Motivation</h1>
<p>Because we believe working with processes in node.js needs too much boilerplate code for most use cases, we reevaluated the current process API and finally built CoreWorker.</p>
<p>CoreWorker aims at simplifying process management by making the most prominent lifecycle events/states explicit so that they can be awaited.</p>
<p>This is done by wrapping some events and hooks around node&apos;s internal process module to determine the exact moments they are triggered.</p>
<h1 id="installation">Installation</h1>
<p>CoreWorker is installable via npm:</p>
<pre><code class="lang-console"><code class="source-code prettyprint">npm install core-worker</code>
</code></pre>
<h1 id="api">API</h1>
<p>By default you can import CoreWorker with <code>import { process } from &quot;core-worker&quot;;</code>. Just call process with a <code>Command</code> and an optional <code>Condition</code> to receive an instance, where <code>Condition</code> is used to determine the moment it is ready. A command has to use absolute paths and should be the same as on your OS specific command line interface.</p>
<pre><code class="lang-c2hs"><code class="source-code prettyprint">typedef process:   Command -&gt; Condition? -&gt; Process
typedef Command:   String
typedef Condition: Nil | String | String -&gt; Boolean | RegExp</code>
</code></pre>
<p>Now you are able to interact with the returned instance in multiple ways: You can wait until the process is ready or dead or use it for example as a stream.  Additionally it is always possible to kill your instance with <code>instance.kill()</code>.</p>
<pre><code class="lang-c2hs"><code class="source-code prettyprint">typedef Process: {
    ready:  Timeout  -&gt; Promise
    death:  Timeout? -&gt; Promise
    stream: Nil      -&gt; Stream
    kill:   Nil      -&gt; Nil
}
typedef Timeout: Integer &amp; x &gt; 0</code>
</code></pre>
<p><code>instance.ready</code> or <code>instance.death</code> will return a Promise object, that either gets fullfilled with a <code>Result</code> or rejected with an <code>Error</code>. If you set a <code>RegExp</code> as the condition, <code>Result</code> will contain the matched string - otherwise there will be <code>Nil</code>.</p>
<pre><code class="lang-c2hs"><code class="source-code prettyprint">typedef Result:  {
    data: String | Nil
}</code>
</code></pre>
<p><code>&#xEC;nstance.stream</code> exposes <code>instance.stdin</code> and <code>instance.stdout</code> / <code>instance.stderr</code> as a stream. Accordingly you can prepend a readable stream to your instance and/or pipe your stream into a writable stream.</p>
<pre><code class="lang-c2hs"><code class="source-code prettyprint">typedef Stream: {
    write: String | Buffer -&gt; Nil
    pipe:  Stream          -&gt; Nil
}</code>
</code></pre>
<h1 id="usage">Usage</h1>
<p>If you just want to wait until some ready condition is reached, create a process with your desired command and your requirement for the ready state of the process. The condition is used to filter incoming data from <code>instance.stdout</code> / <code>instance.stderr</code> until it is triggered. In this case the process is in it&apos;s ready state, which can be reached in three different ways:</p>
<ol>
<li>The <code>condition</code> is a string and the output contains this string</li>
<li>The <code>condition</code> is a regular expression and the output is a match</li>
<li>The <code>condition</code> is a function, takes the output and returns <code>true</code></li>
</ol>
<p>You can now await the ready state with a timeout:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">import { process } from &quot;core-worker&quot;;

const result = await process(&quot;your command&quot;, &quot;condition&quot;).ready(1000);</code>
</code></pre>
<p>As shown in the example below, you can wait until your process has finished. This time a condition does not need to be set, unless you want to wait until the process is ready, too. Afterwards the finished state is awaitable with or without a specified timeout:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">import { process } from &quot;core-worker&quot;;

const result = await process(&quot;your command&quot;).death();</code>
</code></pre>
<p>If you want to compose a chain of streams containing your process, you can use <code>instance.stream</code> to write data into <code>instance.stdin</code> and read data out of <code>instance.stdout</code> / <code>instance.stderr</code>.</p>
<pre><code class="lang-js"><code class="source-code prettyprint">import { process } from &quot;core-worker&quot;;

readstream.pipe(process(&quot;your command&quot;).stream()).pipe(writestream);</code>
</code></pre>
<h1 id="examples">Examples</h1>
<p>The following examples present some common use cases and how they are mastered using CoreWorker:</p>
<h2 id="example-1-wait-until-a-process-is-ready">Example 1 - Wait until a process is ready</h2>
<p>Let&apos;s suppose we want to wait until our HTTP-Server is ready - but no longer than 1000 milliseconds.
So first we write a simple server script ...</p>
<pre><code class="lang-js"><code class="source-code prettyprint">//Server.js
const server = http.createServer(...);

server.listen(1337, &quot;127.0.0.1&quot;, function() {
    // This log will notify our main process when the server is ready to use
    console.log(&quot;Server is ready.&quot;);
});</code>
</code></pre>
<p>... and finally execute it with CoreWorker:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">//startServer.js
import { process } from &quot;core-worker&quot;;

try {
    // Here we define &quot;Server is ready&quot; as our condiition 
    // and use a timeout of 1000ms.
    // Accordingly, the process gets ready when a log 
    // contains this string within the given timeout.
    const result = await process(&quot;node Server.js&quot;, &quot;Server is ready.&quot;).ready(1000);

    console.log(result);
} catch(err) {
    // handle err
}</code>
</code></pre>
<p>The example will start the HTTP-Server and returns a <code>Promise</code>, that either gets resolved with a <code>Result</code> or rejected with an <code>Error</code>. </p>
<p>CoreWorker now evaluates any output with the given <code>Condition</code> (in this case &quot;Server is ready.&quot;). If it is triggered within 1000 milliseconds, the promise gets resolved with an empty <code>Result</code> - otherwise it gets rejected.</p>
<p>Keep in mind, that <code>Result</code> can also return the matched string, if your <code>Condition</code> is a regular expression.</p>
<h2 id="example-2-wait-until-a-process-has-finished">Example 2 - Wait until a process has finished</h2>
<p>This example shows how to wait for a process to be successfully executed and closed.</p>
<p>This time we want to copy a given file, named <code>/path/to/file</code> with the <code>cp</code>-command into a new location <code>/newLocation/copiedFile</code> and wait until this operation has successfully finished:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">import { process } from &quot;core-worker&quot;;

try {
    const result = await process(&quot;cp path/to/file /newLocation/newFile&quot;).death();

    // work with result
} catch(err) {
    // handle err
}</code>
</code></pre>
<p>The example ignores the timeout, since we promise that only this time it&apos;s really acceptable to wait until the end of days for our copy operation to finish :astonished:. So <code>process.death</code> allows you to omit this parameter, even though this isn&apos;t recommended and even forbidden when awaiting the ready state of a process.</p>
<h2 id="example-3-use-a-process-as-a-stream">Example 3 - Use a process as a stream</h2>
<p>This example shows how to compose single processes unix-style. But instead of using the pipe operator | (e.g. <code>cat file.txt | grep something</code>), we can combine them with the canonical &quot;pipe&quot; method exposed by every node.js stream:</p>
<p>So let&apos;s assume that we want to read a file <code>/private/movie/project</code>, ...</p>
<pre><code><code class="source-code prettyprint">It is a period of civil war. Rebel spaceships, striking from a hidden base,
have won their first victory against the evil Galactic Empire.
During the battle, Rebel spies managed to steal secret plans to the Empire&apos;s ultimate weapon,
the DEATH STAR, an armored space station with enough power to destroy an entire planet.
Pursued by the Empire&apos;s sinister agents, Princess Leia races home aboard her starship, 
custodian of the stolen plans that can save her people and restore freedom to the galaxy . . .</code>
</code></pre><p>... grep for &quot;galaxy&quot; and write the results to <code>/ocurrences</code>:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">import { process } from &quot;CoreWorker&quot;;
import fs from &quot;fs&quot;;

fs.createReadStream(file)
    .pipe(process(&quot;grep galaxy&quot;).stream())
    .pipe(fs.createWriteStream(&quot;/ocurrences&quot;));</code>
</code></pre>
<p>By using processes as streams you are generally able to create language agnostic and easily manageable data transform pipelines out of single processes, leveraging all the shiny streaming stuff of node.js.</p>
<h2 id="example-4-use-all-process-functions-at-once">Example 4 - Use all process functions at once</h2>
<p>Sometimes it is necessary to get notified about multiple state changes of a single instance belonging to a specific process while at the same time interacting with it. </p>
<p>Accordingly the next example shows you how to work with multiple instance states at once. We use a simple chat application exemplarily, that logs &quot;Chat ready&quot;, when it is able to accept messages:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">import { process } from &quot;core-worker&quot;;

const simpleChat = process(&quot;node chat.js&quot;, &quot;Chat ready&quot;);

setTimeout(() =&gt; simpleChat.kill(), 360000); // wait an hour and close the chat

simpleChat.ready(500)
    .then(console.log.bind(console, &quot;You are now able to send messages.&quot;))
    .then(::simpleChat.death)
    .then(console.log.bind(console, &quot;Chat closed&quot;))
    .catch(() =&gt; /* handle err */);</code>
</code></pre>
<p>Please note that <code>instance.stream</code> would throw an error, if <code>instance.ready</code> and/or <code>instance.death</code> is executed earlier.</p>
<h1 id="testing">Testing</h1>
<p>You can test CoreWorker with mocha by executing <code>make test</code> in the root directory of the project.</p>
<h1 id="contributing">Contributing</h1>
<p>If you want to contribute to this repository, please ensure ...</p>
<ul>
<li>to use <code>make</code> for development (it validates the source code and transpiles it to <code>/lib</code>).</li>
<li>to follow the existing coding style.</li>
<li>to use the linting tools that are listed in the <code>package.json</code> (which you get for free when using <code>make</code>).</li>
<li>to add and/or customize unit tests for any changed code.</li>
<li>to reference the corresponding issue in your pull request with a small description of your changes.</li>
</ul>
<p>All contributors are listed in the <code>AUTHORS</code> file, sorted by the time of their first contribution.</p>
</div>
</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.5)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
