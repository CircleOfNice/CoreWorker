<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/__tests__/ProcessTest.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/CircleOfNice/CoreWorker" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/DuplexStream.js~DuplexStream.html">DuplexStream</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Process">Process</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-process">process</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Condition">Condition</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-DuplexStream">DuplexStream</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Instance">Instance</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-NodeProcess">NodeProcess</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-null">null</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Process">Process</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RegExp">RegExp</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Result">Result</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Validator">Validator</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/__tests__/ProcessTest.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/*
 * This file is part of CoreWorker.
 *
 * CoreWorker is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * CoreWorker is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with CoreWorker.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 * Copyright 2016 TeeAge-Beatz UG (haftungsbeschr&#xE4;nkt)
 */

import sinon from &quot;sinon&quot;;
import assert from &quot;assert&quot;;
import Process from &quot;../Process&quot;;
import NodeProcess from &quot;../NodeProcess&quot;;
import { assign } from &quot;lodash&quot;;
import TimeoutError from &quot;../TimeoutError&quot;;

const test = (function() {
    const parameters = {
        promises: [],
        resolve:  null,
        spies:    {
            kill:   sinon.spy(),
            stdin:  sinon.spy(),
            stdout: sinon.spy()
        }
    };

    return {
        all:   () =&gt; parameters,
        spies: () =&gt; parameters.spies,
        set:   params =&gt; assign(parameters, params)
    };
}());

const write = chunk =&gt; test.spies().stdin(chunk);

const run = function() {
    assign(this.instance, {
        isRunning: true
    });
    const promises = test.all().promises;

    setTimeout(function() {
        const resolvedValue = test.all().resolve;

        promises.forEach(resolve =&gt; resolve(resolvedValue));
        assign(this.instance, {
            isRunning: false,
            fulfilled: true,
            lastMatch: resolvedValue
        });

        test.set({ promises: [] });
    }.bind(this), 3);
};

const runTimingout = function() {
    assign(this.instance, {
        isRunning: true
    });
    setTimeout(function() {
        this.emitter.emit(&quot;timeout&quot;);
    }.bind(this), 2);
};

const runWithConsoleOutput = function() {
    assign(this.instance, {
        isRunning: true
    });
    this.emitter.on(&quot;data&quot;, data =&gt; this.store(data.toString()));
    this.emitter.on(&quot;data&quot;, data =&gt; this.validate(data.toString()));
    this.emitter.emit(&quot;data&quot;, &quot;Foo&quot;);
    this.emitter.emit(&quot;data&quot;, &quot;Bar&quot;);
    setTimeout(function() {
        this.emitter.emit(&quot;timeout&quot;);
    }.bind(this), 2);
};

const onReady = function(resolve) {
    test.set({
        promises: test.all().promises.concat(resolve)
    });
};

const onDeath = function(deferred) {
    test.set({
        promises: test.all().promises.concat(deferred.resolve)
    });
};

const kill = function(reason) {
    test.spies().kill(reason);
};

const restoreAndSet = function(toRestore, toSet, functionName, stubFunction) {
    toRestore.restore();
    sinon.stub(toSet, functionName, stubFunction);
};

describe(&quot;Process&quot;, function() {
    before(function() {
        sinon.stub(NodeProcess.prototype, &quot;run&quot;, run);
        sinon.stub(NodeProcess.prototype, &quot;write&quot;, write);
        sinon.stub(NodeProcess.prototype, &quot;onReady&quot;, onReady);
        sinon.stub(NodeProcess.prototype, &quot;onDeath&quot;, onDeath);
        sinon.stub(NodeProcess.prototype, &quot;kill&quot;, kill);
        this.clock = sinon.useFakeTimers();
    });

    after(function() {
        NodeProcess.prototype.run.restore();
        NodeProcess.prototype.onReady.restore();
        NodeProcess.prototype.onDeath.restore();
        NodeProcess.prototype.kill.restore();
        NodeProcess.prototype.write.restore();
        this.clock.restore();
    });

    it(&quot;creates a new Instance&quot;, function() {
        const process = Process.create(&quot;node Test.js&quot;, &quot;TestString&quot;);

        assert(process.instance instanceof NodeProcess, &quot;Instance should be instanceof NodeProcess&quot;);
        assert(!process.instance.isRunning(), &quot;Instance shouldn&apos;t run after create&quot;);
        assert(!process.instance.isReady(), &quot;Instanc shouldn&apos;t be ready after create&quot;);
    });

    it(&quot;runs a new Instance and waits until it is ready&quot;, function(done) {
        test.set({ resolve: &quot;TestString&quot; });

        const instance = Process.create(&quot;node Test.js&quot;, &quot;TestString&quot;);

        instance.ready(10).then(function(match) {
            assert.equal(match, &quot;TestString&quot;, &quot;TestString should be resolved&quot;);
            done();
        }).catch(done);

        this.clock.tick(3);
    });

    it(&quot;runs a new Instance and waits until it is ready exceeding given timeout&quot;, function(done) {
        restoreAndSet(NodeProcess.prototype.run, NodeProcess.prototype, &quot;run&quot;, runTimingout);

        const instance = Process.create(&quot;node Test.js&quot;, &quot;TestString&quot;);

        instance.ready(3).then(function() {
            done(new Error(&quot;Promise shouldn&apos;t get resolved&quot;));
        }).catch(function(err) {
            assert(TimeoutError.is(err), &quot;Error is not an instance of TimeoutError&quot;);
            assert.equal(err.message, &quot;Timeout exceeded.&quot;);
            done();
        });

        this.clock.tick(2);

        restoreAndSet(NodeProcess.prototype.run, NodeProcess.prototype, &quot;run&quot;, run);
    });

    it(&quot;runs a new Instance, waits until it is ready exceeding given timeout and checks last process output in error&quot;, function(done) {
        restoreAndSet(NodeProcess.prototype.run, NodeProcess.prototype, &quot;run&quot;, runWithConsoleOutput);

        const instance = Process.create(&quot;node Test.js&quot;, &quot;TestString&quot;);

        instance.ready(3).then(function() {
            done(new Error(&quot;Promise shouldn&apos;t get resolved&quot;));
        }).catch(function(err) {
            assert(TimeoutError.is(err), &quot;Error is not an instance of TimeoutError&quot;);
            assert.equal(err.message, &quot;Timeout exceeded. Last process output is: Bar&quot;);
            done();
        });

        this.clock.tick(2);

        restoreAndSet(NodeProcess.prototype.run, NodeProcess.prototype, &quot;run&quot;, run);
    });

    it(&quot;runs a new Instance and waits until death&quot;, function(done) {
        test.set({
            resolve: {
                data: &quot;TestString&quot;
            }
        });

        const instance = Process.create(&quot;node Test.js&quot;, &quot;TestString&quot;);

        instance.death().then(function(data) {
            assert.deepStrictEqual(data, { data: &quot;TestString&quot; }, `TestString should be resolved: \n ${JSON.stringify(data)}`);
            done();
        }).catch(done);

        this.clock.tick(3);
    });

    it(&quot;runs a new Instance and waits until death exceeding given timeout&quot;, function(done) {
        restoreAndSet(NodeProcess.prototype.run, NodeProcess.prototype, &quot;run&quot;, runTimingout);

        const instance = Process.create(&quot;node Test.js&quot;, &quot;TestString&quot;);

        instance.death(1).then(function() {
            done(new Error(&quot;Promise shouldn&apos;t get resolved.&quot;));
        }).catch(function(err) {
            assert(TimeoutError.is(err), &quot;Error is not an instance of TimeoutError&quot;);
            assert.equal(err.message, &quot;Timeout exceeded.&quot;);
            done();
        });

        this.clock.tick(2);

        restoreAndSet(NodeProcess.prototype.run, NodeProcess.prototype, &quot;run&quot;, run);
    });

    it(&quot;runs a new Instance, waits until death exceeding given timeout and checks last process output in error&quot;, function(done) {
        restoreAndSet(NodeProcess.prototype.run, NodeProcess.prototype, &quot;run&quot;, runWithConsoleOutput);

        const instance = Process.create(&quot;node Test.js&quot;, &quot;TestString&quot;);

        instance.death(1).then(function() {
            done(new Error(&quot;Promise shouldn&apos;t get resolved.&quot;));
        }).catch(function(err) {
            assert(TimeoutError.is(err), &quot;Error is not an instance of TimeoutError&quot;);
            assert.equal(err.message, &quot;Timeout exceeded. Last process output is: Bar&quot;);
            done();
        });

        this.clock.tick(2);

        restoreAndSet(NodeProcess.prototype.run, NodeProcess.prototype, &quot;run&quot;, run);
    });

    it(&quot;runs a new Instance and returns a stream&quot;, function() {
        test.set({ resolve: &quot;TestString&quot; });

        const process = Process.create(&quot;node Test.js&quot;, &quot;TestString&quot;);
        const stream  = process.stream();
        const pipeSpy = sinon.spy();

        stream.pipe({
            write: pipeSpy,
            on:    () =&gt; {},
            once:  () =&gt; {},
            emit:  () =&gt; {}
        });
        stream.write(&quot;Test&quot;);

        assert(test.spies().stdin.calledWith(new Buffer(&quot;Test&quot;)), `stdinSpy was called with wrong args: \n ${test.spies().stdin.lastCall.args}`);

        process.instance.emitter.emit(&quot;data&quot;, &quot;Test2&quot;);
        assert(pipeSpy.calledWith(new Buffer(&quot;Test2&quot;)), `pipeSpy was called with wrong args: \n ${pipeSpy.lastCall.args}`);

        assert.throws(process.stream, &quot;It should only run one instance&quot;);
    });
});
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.6)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
