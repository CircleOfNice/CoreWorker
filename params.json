{"name":"Coreworker","tagline":"Manage Your Processes - Like a Boss.","body":"# CoreWorker\r\n<img src=\"https://scontent-frt3-1.cdninstagram.com/hphotos-xap1/t51.2885-15/e15/11281977_943814572305837_858119153_n.jpg\" />\r\n\r\n# Motivation\r\nBecause we believe working with processes in node.js needs too much boilerplate code for most use cases, we reevaluated the current process API and finally built CoreWorker.\r\n\r\nCoreWorker aims at simplifying process management by making the most prominent lifecycle events/states explicit so that they can be awaited.\r\n\r\nThis is done by wrapping some events and hooks around node's internal process module to determine the exact moments they are triggered.\r\n\r\n# Installation\r\n\r\nCoreWorker is installable via npm:\r\n```console\r\nnpm install core-worker\r\n``` \r\n\r\n# API\r\nBy default you can import CoreWorker with ```import { process } from \"core-worker\";```. Just call process with a ```Command``` and an optional ```Condition``` to receive an instance, where ```Condition``` is used to determine the moment it is ready. A command has to use absolute paths and should be the same as on your OS specific command line interface.\r\n```c2hs\r\ntypedef process:   Command -> Condition? -> Process\r\ntypedef Command:   String\r\ntypedef Condition: Nil | String | String -> Boolean | RegExp\r\n```\r\nNow you are able to interact with the returned instance in multiple ways: You can wait until the process is ready or dead or use it for example as a stream.  Additionally it is always possible to kill your instance with ```instance.kill()```.\r\n```c2hs\r\ntypedef Process: {\r\n    ready:  Timeout  -> Promise\r\n    death:  Timeout? -> Promise\r\n    stream: Nil      -> Stream\r\n    kill:   Nil      -> Nil\r\n}\r\ntypedef Timeout: Integer & x > 0\r\n```\r\n```instance.ready``` or ```instance.death``` will return a Promise object, that either gets fullfilled with a ```Result``` or rejected with an ```Error```. If you set a ```RegExp``` as the condition, ```Result``` will contain the matched string - otherwise there will be ```Nil```.\r\n```c2hs\r\ntypedef Result:  {\r\n    data: String | Nil\r\n}\r\n```\r\n```Ã¬nstance.stream``` exposes ```instance.stdin``` and ```instance.stdout``` / ```instance.stderr``` as a stream. Accordingly you can prepend a readable stream to your instance and/or pipe your stream into a writable stream.\r\n```c2hs\r\ntypedef Stream: {\r\n    write: String | Buffer -> Nil\r\n    pipe:  Stream          -> Nil\r\n}\r\n```\r\n\r\n# Usage\r\nIf you just want to wait until some ready condition is reached, create a process with your desired command and your requirement for the ready state of the process. The condition is used to filter incoming data from ```instance.stdout``` / ```instance.stderr``` until it is triggered. In this case the process is in it's ready state, which can be reached in three different ways:\r\n  1. The ```condition``` is a string and the output contains this string\r\n  2. The ```condition``` is a regular expression and the output is a match\r\n  3. The ```condition``` is a function, takes the output and returns ```true```\r\n\r\nYou can now await the ready state with a timeout:\r\n```js\r\nimport { process } from \"core-worker\";\r\n\r\nconst result = await process(\"your command\", \"condition\").ready(1000);\r\n```\r\n\r\nAs shown in the example below, you can wait until your process has finished. This time a condition does not need to be set, unless you want to wait until the process is ready, too. Afterwards the finished state is awaitable with or without a specified timeout:\r\n```js\r\nimport { process } from \"core-worker\";\r\n\r\nconst result = await process(\"your command\").death();\r\n```\r\n\r\nIf you want to compose a chain of streams containing your process, you can use ```instance.stream``` to write data into ```instance.stdin``` and read data out of ```instance.stdout``` / ```instance.stderr```.\r\n```js\r\nimport { process } from \"core-worker\";\r\n\r\nreadstream.pipe(process(\"your command\").stream()).pipe(writestream);\r\n```\r\n\r\n# Examples\r\nThe following examples present some common use cases and how they are mastered using CoreWorker:\r\n\r\n## Example 1 - Wait until a process is ready\r\nLet's suppose we want to wait until our HTTP-Server is ready - but no longer than 1000 milliseconds.\r\nSo first we write a simple server script ...\r\n```js\r\n//Server.js\r\nconst server = http.createServer(...);\r\n\r\nserver.listen(1337, \"127.0.0.1\", function() {\r\n    // This log will notify our main process when the server is ready to use\r\n    console.log(\"Server is ready.\");\r\n});\r\n```\r\n... and finally execute it with CoreWorker:\r\n```js\r\n//startServer.js\r\nimport { process } from \"core-worker\";\r\n\r\ntry {\r\n    // Here we define \"Server is ready\" as our condiition \r\n    // and use a timeout of 1000ms.\r\n    // Accordingly, the process gets ready when a log \r\n    // contains this string within the given timeout.\r\n    const result = await process(\"node Server.js\", \"Server is ready.\").ready(1000);\r\n    \r\n    console.log(result);\r\n} catch(err) {\r\n    // handle err\r\n}\r\n```\r\nThe example will start the HTTP-Server and returns a ```Promise```, that either gets resolved with a ```Result``` or rejected with an ```Error```. \r\n\r\nCoreWorker now evaluates any output with the given ```Condition``` (in this case \"Server is ready.\"). If it is triggered within 1000 milliseconds, the promise gets resolved with an empty ```Result``` - otherwise it gets rejected.\r\n\r\nKeep in mind, that ```Result``` can also return the matched string, if your ```Condition``` is a regular expression.\r\n\r\n## Example 2 - Wait until a process has finished\r\nThis example shows how to wait for a process to be successfully executed and closed.\r\n\r\nThis time we want to copy a given file, named ```/path/to/file``` with the ```cp```-command into a new location ```/newLocation/copiedFile``` and wait until this operation has successfully finished:\r\n\r\n```js\r\nimport { process } from \"core-worker\";\r\n\r\ntry {\r\n    const result = await process(\"cp path/to/file /newLocation/newFile\").death();\r\n    \r\n    // work with result\r\n} catch(err) {\r\n    // handle err\r\n}\r\n```\r\nThe example ignores the timeout, since we promise that only this time it's really acceptable to wait until the end of days for our copy operation to finish :astonished:. So ```process.death``` allows you to omit this parameter, even though this isn't recommended and even forbidden when awaiting the ready state of a process.\r\n\r\n## Example 3 - Use a process as a stream\r\nThis example shows how to compose single processes unix-style. But instead of using the pipe operator | (e.g. ```cat file.txt | grep something```), we can combine them with the canonical \"pipe\" method exposed by every node.js stream:\r\n\r\nSo let's assume that we want to read a file ```/private/movie/project```, ...\r\n```\r\nIt is a period of civil war. Rebel spaceships, striking from a hidden base,\r\nhave won their first victory against the evil Galactic Empire.\r\nDuring the battle, Rebel spies managed to steal secret plans to the Empire's ultimate weapon,\r\nthe DEATH STAR, an armored space station with enough power to destroy an entire planet.\r\nPursued by the Empire's sinister agents, Princess Leia races home aboard her starship, \r\ncustodian of the stolen plans that can save her people and restore freedom to the galaxy . . .\r\n```\r\n... grep for \"galaxy\" and write the results to ```/ocurrences```:\r\n```js\r\nimport { process } from \"CoreWorker\";\r\nimport fs from \"fs\";\r\n\r\nfs.createReadStream(file)\r\n    .pipe(process(\"grep galaxy\").stream())\r\n    .pipe(fs.createWriteStream(\"/ocurrences\"));\r\n```\r\nBy using processes as streams you are generally able to create language agnostic and easily manageable data transform pipelines out of single processes, leveraging all the shiny streaming stuff of node.js.\r\n\r\n## Example 4 - Use all process functions at once\r\nSometimes it is necessary to get notified about multiple state changes of a single instance belonging to a specific process while at the same time interacting with it. \r\n\r\nAccordingly the next example shows you how to work with multiple instance states at once. We use a simple chat application exemplarily, that logs \"Chat ready\", when it is able to accept messages:\r\n```js\r\nimport { process } from \"core-worker\";\r\n\r\nconst simpleChat = process(\"node chat.js\", \"Chat ready\");\r\n\r\nsetTimeout(() => simpleChat.kill(), 360000); // wait an hour and close the chat\r\n\r\nsimpleChat.ready(500)\r\n    .then(console.log.bind(console, \"You are now able to send messages.\"))\r\n    .then(::simpleChat.death)\r\n    .then(console.log.bind(console, \"Chat closed\"))\r\n    .catch(() => /* handle err */);\r\n```\r\nPlease note that ```instance.stream``` would throw an error, if ```instance.ready``` and/or ```instance.death``` is executed earlier.\r\n\r\n# Testing\r\n\r\nYou can test CoreWorker with mocha by executing ```make test``` in the root directory of the project.\r\n\r\n# Contributing\r\n\r\nIf you want to contribute to this repository, please ensure ...\r\n  - to use ```make``` for development (it validates the source code and transpiles it to ```/lib```).\r\n  - to follow the existing coding style.\r\n  - to use the linting tools that are listed in the ```package.json``` (which you get for free when using ```make```).\r\n  - to add and/or customize unit tests for any changed code.\r\n  - to reference the corresponding issue in your pull request with a small description of your changes.\r\n\r\nAll contributors are listed in the ```AUTHORS``` file, sorted by the time of their first contribution.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}